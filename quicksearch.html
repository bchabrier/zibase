<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"zibase.js.html":{"id":"zibase.js.html","title":"Source: zibase.js","body":" DocStrap Global ZbActionZbProtocolZbRequestZbResponseZbVirtualProbeZiBase Source: zibase.js //heaviliy inpspired from Benjamin Garel's PHP SDK, located in // http://bgarel.free.fr/Zibase/ var http = require(&quot;http&quot;); var request = require(&quot;request&quot;); var net = require(&quot;net&quot;); var url = require(&quot;url&quot;); var dgram = require(&quot;dgram&quot;); var util = require(&quot;util&quot;); var events = require(&quot;events&quot;); var assert = require(&quot;assert&quot;); var logger = require(&quot;tracer&quot;).colorConsole({ transport : function (data) { console.log(data.output); if (exports.test_logger == true) { exports.test_logger_data = data; } }, dateformat : &quot;dd/mm/yyyy HH:MM:ss.l&quot;, level : 3 //0:'test', 1:'trace', 2:'debug', 3:'info', 4:'warn', 5:'error' }); /** * Enum des protocoles Zibase */ var ZbProtocol = new function () { this.PRESET = 0; this.VISONIC433 = 1; this.VISONIC868 = 2; this.CHACON = 3; this.DOMIA = 4; this.X10 = 5; this.ZWAVE = 6; this.RFS10 = 7; this.X2D433 = 8; this.X2D433ALRM = 8; this.X2D868 = 9; this.X2D868ALRM = 9; this.X2D868INSH = 10; this.X2D868PIWI = 11; this.X2D868BOAC = 12; }; exports.ZbProtocol = ZbProtocol; /** * Enum des sondes virtuelles */ var ZbVirtualProbe = new function () { this.OREGON = 17; this.OWL = 20; }; /** * Enum des actions possibles par la Zibase */ var ZbAction = new function () { this.OFF = 0; this.ON = 1; this.DIM_BRIGHT = 2; this.ALL_LIGHTS_ON = 4; this.ALL_LIGHTS_OFF = 5; this.ALL_OFF = 6; this.ASSOC = 7; }; exports.ZbAction = ZbAction; /** * Enum des états possibles des alertes de la Zibase var ZbEventType = new function () { this.OFF = 9; this.ON = 4; }; exports.ZbEventType = ZbEventType; */ /** * Requête spécifique pour la Zibase */ function ZbRequest() { this.header = &quot;ZSIG&quot;; this.command = 0; this.reserved1 = &quot;&quot;; this.zibaseId = &quot;&quot;; this.reserved2 = &quot;&quot;; this.param1 = 0; this.param2 = 0; this.param3 = 0; this.param4 = 0; this.myCount = 0; this.yourCount = 0; this.message = null; } /** * Formate la requête en chaîne binaire compatible Zibase * @return la chaîne binaire */ ZbRequest.prototype.toBinaryArray = function() { var header = new Buffer(this.header); var command = new Buffer(2) command.writeUInt16BE(this.command, 0); var reserved1 = new Buffer(16); reserved1.fill(String.fromCharCode(0)); reserved1.write(this.reserved1); var zibaseId = new Buffer(16); zibaseId.fill(String.fromCharCode(0)); zibaseId.write(this.zibaseId); var reserved2 = new Buffer(12); reserved2.fill(String.fromCharCode(0)); reserved2.write(this.reserved2); var param1 = new Buffer(4); param1.writeUInt32BE(this.param1, 0); var param2 = new Buffer(4); param2.writeUInt32BE(this.param2, 0); var param3 = new Buffer(4); param3.writeUInt32BE(this.param3, 0); var param4 = new Buffer(4); param4.writeUInt32BE(this.param4, 0); var myCount = new Buffer(2); myCount.writeUInt16BE(this.myCount, 0); var yourCount = new Buffer(2); yourCount.writeUInt16BE(this.yourCount, 0); var data; if (this.message != null) { var message = new Buffer(96); message.fill(String.fromCharCode(0)); message.write(this.message); data = Buffer.concat([header, command, reserved1, zibaseId, reserved2, param1, param2, param3, param4, myCount, yourCount, message]); } else { data = Buffer.concat([header, command, reserved1, zibaseId, reserved2, param1, param2, param3, param4, myCount, yourCount]); } logger.debug(data) return data; } /** * Réponse spécifique de la Zibase */ function ZbResponse(buffer) { /** * Construit la réponse à partir des données binaires envoyées par la Zibase */ var tempString = &quot;&quot;; this.header = buffer.toString('utf8', 0, 4); this.command = buffer.readUInt16BE(4); tempString = buffer.toString('utf8', 6, 21); this.reserved1 = tempString.substr(0, tempString.indexOf('\\u0000')); tempString = buffer.toString('utf8', 22, 37); this.zibaseId = tempString.substr(0, tempString.indexOf('\\u0000')); tempString = buffer.toString('utf8', 38, 49); this.reserved2 = tempString.substr(0, tempString.indexOf('\\u0000')); this.param1 = buffer.readUInt32BE(50); this.param2 = buffer.readUInt32BE(54); this.param3 = buffer.readUInt32BE(58); this.param4 = buffer.readUInt32BE(62); this.myCount = buffer.readUInt16BE(64); this.yourCount = buffer.readUInt16BE(66); tempString = buffer.toString('utf8', 70); this.message = tempString.substr(0, tempString.indexOf('\\u0000')); }; /** * Permet de manipuler la ZiBase. * Il est nécessaire de connaître l'adresse IP de sa zibase pour l'utiliser. * @param string $ipAddr Adresse IP de la zibase * @param string $deviceId Device de la zibase * @param string $token Token de la zibase */ function ZiBase(ipAddr, deviceId, token, callback) { this.ip = ipAddr; this.port = 49999; this.localport = undefined; this.myip = require(&quot;ip&quot;).address(); this.deregistered = false; // true if deregistration has been requested this.deviceId = deviceId; this.token = token; this.timeZone = &quot;Europe/Paris&quot;; events.EventEmitter.call(this); this.emitEvent = function(event, arg1, arg2) { if (arg2) { var id = arg1; var arg = arg2; this.emit(event + &quot;:&quot; + id, arg); } else { this.emit(event, arg1); } } var self = this; this.loadDescriptors(function(err) { self.listenToZiBase(self.processZiBaseData); if (callback != null) callback(); }); } util.inherits(ZiBase, events.EventEmitter); exports.ZiBase = ZiBase; /* * Load the descriptors of declared devices and scenarios */ ZiBase.prototype.loadDescriptors = function(cb) { this.descriptors = []; this.descriptorsByID = []; var self = this; request.get(&quot;https://zibase.net/m/get_xml.php?device=&quot; + this.deviceId + &quot;&amp;token=&quot; + this.token, function(error, response, bodyString) { var re = /&lt;([m|e])\\s+([^&gt;]*)&gt;\\s*&lt;n&gt;([^&lt;]*)&lt;\\/n&gt;\\s*&lt;\\/[m|e]&gt;/g; var match; while (( match = re.exec(bodyString)) != undefined) { var type=match[1]; var props=match[2]; var name=match[3]; var desc = {}; switch(type) { case 'e': desc.type = &quot;device&quot;; break; case 'm': desc.type = &quot;scenario&quot;; break; default: desc.type = &quot;&quot;; logger.error(&quot;unexpected type '&quot; + type + &quot;' from zibase descriptors, 'e' or 'm' expected.&quot;); break; } desc.name = name; var rep = /([^=]+)=&quot;([^&quot;]*)&quot;\\s*/g; var matchp; while (( matchp = rep.exec(props)) != undefined) { var id = matchp[1]; var value = matchp[2]; desc[id] = value; } self.descriptors.push(desc); var id = desc.type == &quot;device&quot;?&quot;c&quot;:&quot;id&quot;; assert.notEqual(desc[id], undefined); if (desc.type == &quot;device&quot; &amp;&amp; desc.p == 6) { // ZWave self.descriptorsByID[&quot;Z&quot; + desc[id]] = desc; } else self.descriptorsByID[desc[id]] = desc; } cb(null); }); } /* * retrieve the descriptor with a given id */ ZiBase.prototype.getDescriptor = function(id) { return this.descriptorsByID[id]; } ZiBase.prototype.on = function(event, id, callback) { if (( typeof event === 'string') &amp;&amp; ( typeof id === 'string') &amp;&amp; ( typeof callback === 'function')) { event = event + &quot;:&quot; + id } if (( typeof event === 'string') &amp;&amp; ( typeof id === 'function') &amp;&amp; ( typeof callback === 'undefined')) { callback = id } ZiBase.super_.prototype.on.call(this, event, callback); } ZiBase.prototype.once = function(event, id, callback) { if (( typeof event === 'string') &amp;&amp; ( typeof id === 'string') &amp;&amp; ( typeof callback === 'function')) { // normal call event = event + &quot;:&quot; + id } if (( typeof event === 'string') &amp;&amp; ( typeof id === 'function') &amp;&amp; ( typeof callback === 'undefined')) { callback = id } ZiBase.super_.prototype.once.call(this, event, callback); //logger.error(this) } ZiBase.prototype.processZiBaseData = function(response) { //response.message = &quot;Received radio ID (&lt;rf&gt;433Mhz&lt;/rf&gt; Noise=&lt;noise&gt;2090&lt;/noise&gt; Level=&lt;lev&gt;2.3&lt;/lev&gt;&lt;id&gt;OS3930858754&lt;/id&gt;&quot; if (response.reserved1 == &quot;TEXTMSG&quot;) { function replaceid(zb, message, entire_string, id, before, id_modified, after){ var name; var desc = zb.descriptorsByID[id]; if (desc != undefined) name = desc.name; if (name != undefined) { return message.replace(entire_string, before+id_modified+&quot; (&quot;+name+&quot;)&quot;+after); } return message; } var infos = {}; //Received radio ID (&lt;rf&gt;ZWAVE ZA5&lt;/rf&gt; &lt;dev&gt;CMD/INTER&lt;/dev&gt; Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;ZA5_OFF&lt;/id&gt; if (/Received radio ID \\(.*CMD\\/INTER/.test(response.message)) { var re = /([^:]+:\\s*&lt;id&gt;)(([^_]+)(_OFF)?)(&lt;\\/id&gt;)/; if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = (match[4] == undefined) ? &quot;ON&quot; : &quot;OFF&quot; } var msg =replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; match[5] // end ); logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //Received radio ID (&lt;rf&gt;433Mhz&lt;/rf&gt; Noise=&lt;noise&gt;2175&lt;/noise&gt; Level=&lt;lev&gt;2.3&lt;/lev&gt;/5 &lt;dev&gt;Oregon THWR288A-THN132N&lt;/dev&gt; Ch=&lt;ch&gt;2&lt;/ch&gt; T=&lt;tem&gt;+3.7&lt;/tem&gt;°C (+38.6°F) Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;OS3930858754&lt;/id&gt; else if (/Received radio ID \\(/.test(response.message)) { var re = /&lt;([^&gt;]+)&gt;([^&lt;]*)&lt;\\/(\\1)&gt;/g while (( match = re.exec(response.message)) != null) { logger.trace(match); infos[match[1]] = match[2]; } var trace = replaceid(this, response.message, &quot;&lt;id&gt;&quot; + infos[&quot;id&quot;] + &quot;&lt;/id&gt;&quot;, // entire string infos[&quot;id&quot;], // ID &quot;&lt;id&gt;&quot;, // start infos[&quot;id&quot;], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&lt;/id&gt;&quot; // end ); re = /(&lt;rf&gt;ZWAVE )([^&lt;]+)(&lt;\\/rf&gt;)/; if ((match = re.exec(trace)) != null) { trace = replaceid(this, trace, match[0], // entire string match[2], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; match[3] // end ); } logger.info(trace); this.emitEvent(&quot;message&quot;, {message: trace, raw_message: response.reserved1}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //Sent radio ID (1 Burst(s), Protocols='Family http' ): I5_OFF else if (/Sent radio ID \\(/.test(response.message)) { var msg; var re = /([^:]+:\\s*)(([^_]+)(_OFF|_ON)?)/ if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = (match[4] == &quot;_OFF&quot;) ? &quot;OFF&quot; : &quot;ON&quot; msg=replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); logger.info(msg); } else { msg=response.message; logger.error(&quot;Error, regexp &quot; + re + &quot; not found in response.message!&quot;); logger.info(response.message); } this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //ZWave warning - Device ZA8 is unreachable! : ERR_ZA8 else if (/ZWave warning/.test(response.message)) { var re = /([^:]+:\\s*)(ERR_([^_]+))/; var msg; if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = &quot;ERR&quot;; logger.debug(infos); logger.debug(match); msg=replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); } else { msg=response.message; logger.error(&quot;Error, regexp &quot; + re + &quot; not found in response.message!&quot;); } logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); if (infos.id != undefined) { this.emitEvent(&quot;error&quot;, infos.id, infos) } } // Completed SCENARIO: 45 else if (/(Completed|Launch) SCENARIO:/.test(response.message)) { var re = /(SCENARIO: )([0-9]+)/; if (( match = re.exec(response.message)) != null) { logger.trace(match); } var msg=replaceid(this, response.message, match[0], // entire string match[2], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); } else { logger.info(response.message); this.emitEvent(&quot;message&quot;, {message: response.message, raw_message: response.message}); } } else if (response.reserved1 == &quot;SLAMSIG&quot;) { this.emitEvent(&quot;restart&quot;); // zibase is restarting // let's reinit self = this; this.loadDescriptors(function (err) { // deregister first, just in case self.deregisterListener(); // then re-listen to zibase self.deregistered = false; self.listenToZiBase(self.processZiBaseData); }); } else { logger.warn(&quot;Unsupported response:&quot;, response) } }; var messageQueue = []; function nextCallback() { logger.debug(&quot;nextCallback called&quot;) // removing previous request, which has been handled messageQueue.shift(); // check if still a message to process if (messageQueue.length &gt; 0) { logger.debug(&quot;queue not empty; processing&quot;) var callback = messageQueue[0]; logger.debug(callback) callback(); } }; function pushRequest(requestFunc) { logger.debug(&quot;pushing request&quot;) messageQueue.push(requestFunc) if (messageQueue.length === 1) { logger.debug(&quot;queue was empty, processing&quot;) requestFunc() } else { logger.debug(&quot;queue not empty, waiting&quot;) } } /** * Envoie la requête à la Zibase sur le réseau * @param ZbRequest requête au format Zibase */ ZiBase.prototype.sendRequest = function(request, withResponse, callback) { logger.debug('request=', request); if (withResponse == undefined) { withResponse = true } var socket = dgram.createSocket('udp4'); var self = this; pushRequest(function() { if (withResponse) { var t = setTimeout(function() { var address = socket.address(); var err = new Error(&quot;socket timeout while waiting for response on &quot; + socket.address().port); socket.close(); callback(err, undefined) nextCallback(); }, 10000); // 10 seconds socket.on(&quot;message&quot;, function(msg, rinfo) { clearTimeout(t); logger.trace(&quot;socket got: &quot; + msg + &quot; from &quot; + rinfo.address + &quot;:&quot; + rinfo.port); var response = null; if (msg.length &gt; 0) { response = new ZbResponse(msg); logger.trace(&quot;response=&quot;, response) callback(null, response); } logger.debug(&quot;socket closing &quot; + socket.address().port); socket.close(); nextCallback(); }); socket.on(&quot;listening&quot;, function() { var address = socket.address(); logger.debug(&quot;socket listening from SendRequest on &quot; + address.port); }); socket.on(&quot;error&quot;, function() { var address = socket.address(); logger.error(&quot;socket error on port &quot; + address.port); nextCallback(); }); socket.bind(); } var buffer = request.toBinaryArray(); socket.send(buffer, 0, buffer.length, self.port, self.ip, function(err, bytes) { logger.trace(&quot;buffer.length=&quot;, buffer.length); logger.trace(&quot;err=&quot;, err); logger.trace(&quot;bytes=&quot;, bytes); logger.trace(&quot;fin&quot;); if (!withResponse) { logger.debug(&quot;socket closing &quot; + socket.address().port); socket.close(); nextCallback(); } }); }); }; /** * Lance la commande RF de l'actionneur spécifié par son adresse et son protocol * @param string $address Adresse au format X10 de l'actionneur (ex: B5) * @param int $action Action à réaliser (Utiliser l'enum ZbAction) * @param int $protocol Protocole RF (Utiliser l'enum ZbProtocol) * @param int $dimLevel Non supporté par la zibase pour l'instant * @param int $nbBurst Nombre d'émissions RF */ ZiBase.prototype.sendCommand = function(address, action, protocol, dimLevel, nbBurst) { logger.debug(&quot;params:&quot;, address, action, protocol, dimLevel, nbBurst) if (protocol == undefined) { protocol = ZbProtocol.PRESET } if (dimLevel == undefined) { dimLevel = 0 } if (nbBurst == undefined) { nbBurst = 1 } if (/^[zZ]?[a-pA-P]([1-9]|1[0-6])$/.test(address)) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { address = address.substr(1); protocol = ZbProtocol.ZWAVE; } var request = new ZbRequest(); request.command = 11; if (action == ZbAction.DIM_BRIGHT &amp;&amp; dimLevel == 0) action = ZbAction.OFF; request.param2 = action; logger.debug(&quot;action = &quot;, action) request.param2 |= (protocol &amp; 0xFF) &lt;&lt; 0x08; if (action == ZbAction.DIM_BRIGHT) request.param2 |= (dimLevel &amp; 0xFF) &lt;&lt; 0x10; if (nbBurst &gt; 1) request.param2 |= (nbBurst &amp; 0xFF) &lt;&lt; 0x18; request.param3 = 0 + address.substr(1) - 1; request.param4 = address.charCodeAt(0) - 0x41; this.sendRequest(request, true, function(response) { logger.debug(&quot;response from Zibase = &quot;, response); }); } else { throw new Error(&quot;address must be (Z)[A-P]1-16.&quot;) } }; /** * Lance le scenario spécifié par son numéro. * Le numéro du scenario est indiqué entre parenthèse * dans le suivi d'activité de la console de configuration. * @param int numScenario Le numéro du scenario */ ZiBase.prototype.runScenario = function(numScenario) { logger.info(&quot;runScenario&quot;, numScenario); var request = new ZbRequest(); request.command = 11; request.param1 = 1; request.param2 = numScenario; this.sendRequest(request, true, function(response) { logger.info(&quot;response from Zibase = &quot;, response); }); } /** * Positionne une alerte à l’état ON / OFF ou simule * l’arrivée d’un ID détecteur. * dans le suivi d'activité de la console de configuration. * @param int action L'action: 0 - inactiver une alerte, 1 - activer une alerte, 2 - simuler l’arrivée d’un ID de détecteur (peut entraîner l’exécution de scénarios) * @param String address au format X10 de l'actionneur (ex: B5 ou ZA14) */ ZiBase.prototype.setEvent = function(action, address) { logger.info(&quot;setEvent&quot;, action, address); var request = new ZbRequest(); request.command = 11; request.param1 = 4; request.param2 = action; var ev_type; if (action == 0) { ev_type = 9 } if (action == 1 || action == 2) { ev_type = 4 } var protocol; if (address.length &gt; 1) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { address = address.substr(1); protocol = ZbProtocol.ZWAVE; } var letter = address.charCodeAt(0) - 0x41; var device = 0 + address.substr(1) - 1; var id = letter * 16 + device } request.param3 = id; if (protocol == ZbProtocol.ZWAVE) { if (ev_type == 4) ev_type = 19 if (ev_type == 9) ev_type = 20 } request.param4 = ev_type; this.sendRequest(request, false, function(response) { logger.info(&quot;response from Zibase = &quot;, response); }); } /** * Récupère la valeur d'une variable Vx de la Zibase * @param int $numVar le numéro de la variable (0 à 19) * @return int la valeur de la variable demandée */ ZiBase.prototype.getVariable = function(numVar, callback) { logger.trace(&quot;entering getVariable&quot;, numVar); var request = new ZbRequest(); request.command = 11; request.param1 = 5; request.param3 = 0; request.param4 = numVar; this.sendRequest(request, true, function(err, response) { logger.debug(&quot;getVariable&quot;, numVar, &quot;=&gt; err=&quot;, err, &quot;value=&quot;, (response != null) ? response.param1 : null); callback(err, (response != null) ? response.param1 : null); }); } /** * Enregistre une machine en tant qu'écouteur * @param string $ip l'adresse IP de l'écouteur * @param int $port le port sur lequel écouter */ ZiBase.prototype.registerListener = function(port) { this.localport = port; var ip = this.myip; logger.debug(&quot;registerListener&quot;, ip, port); var request = new ZbRequest(); request.command = 13; request.param1 = ip2long(ip); request.param2 = port; request.param3 = 0; request.param4 = 0; this.sendRequest(request, false); }; /** * Désenregistre une machine en tant qu'écouteur */ ZiBase.prototype.deregisterListener = function() { logger.debug(&quot;deregisterListener&quot;, this.myip, this.localport); this.deregistered = true; if (this.socket != undefined) { this.socket.close(); this.socket = undefined; } var request = new ZbRequest(); request.command = 22; request.param1 = ip2long(this.myip); request.param2 = this.localport; request.param3 = 0; request.param4 = 0; this.sendRequest(request, false); }; /** * Récupère l'état d'un actionneur. * La zibase ne recoit que les ordres RF et non les ordres CPL X10, * donc l'état d'un actionneur X10 connu par la zibase peut être erronné. * @param string adresse au format X10 de l'actionneur * @return int l'état : 0=OFF, 1=ON */ ZiBase.prototype.getState = function(address, callback) { logger.trace(&quot;getState&quot;, address); var isZWave = false; if (address.length &gt; 1) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { isZWave = true; address = address.substr(1); } } if (address.length &gt; 1) { var request = new ZbRequest(); request.command = 11; request.param1 = 5; request.param3 = 4; var houseCode = address.charCodeAt(0) - 0x41; var device = 0 + address.substr(1) - 1; request.param4 = device; request.param4 |= (houseCode &amp; 0x0F) &lt;&lt; 0x04; // Pour le zwave, il faut mettre le 9e bit à 1 if (isZWave) request.param4 |= 0x0100; this.sendRequest(request, true, function(err, response) { logger.debug(&quot;getState&quot;, address, &quot;=&gt; err=&quot;, err, &quot;value=&quot;, (response != null) ? response.param1 : null); callback(err, (response != null) ? response.param1 : null); }); } }; ZiBase.prototype.getSensorInfo = function(idSensor, callback) { var typeSensor = idSensor.substring(0, 2); var numberSensor = idSensor.substring(2, 10000); var zibaseIP = this.ip; request.get(&quot;http://&quot; + zibaseIP + &quot;/sensors.xml&quot;, {timeout: 10000}, function(err, response, bodyString) { var re = new RegExp('&lt;ev type=&quot;([^&quot;]*)&quot; +pro=&quot;' + typeSensor + '&quot; +id=&quot;' + numberSensor + '&quot; +gmt=&quot;([^&quot;]*)&quot; +v1=&quot;([^&quot;]*)&quot; +v2=&quot;([^&quot;]*)&quot; +lowbatt=&quot;([^&quot;]*)&quot;/&gt;', &quot;g&quot;); var match; if (( match = re.exec(bodyString)) != undefined) { for ( i = 1; i &lt; match.length; i++) { var to = match[i]; logger.trace(to); } var type = match[1]; // var pro = match[2]; // var id = match[3]; var gmt = match[2]; var v1 = match[3]; var v2 = match[4]; var lowbat = match[5]; // create a new javascript Date object based on the timestamp // multiplied by 1000 so that the argument is in milliseconds, not seconds var date = new Date(gmt * 1000); // hours part from the timestamp var hours = date.getHours(); // minutes part from the timestamp var minutes = date.getMinutes(); // seconds part from the timestamp var seconds = date.getSeconds(); logger.trace(&quot;date=&quot;, date); logger.trace(&quot;v1=&quot;, v1); logger.trace(&quot;v2=&quot;, v2); var results = new Object results.date = date results.v1 = v1 results.v2 = v2 callback(null, results); } else { // found nothing callback(new Error(&quot;idSensor '&quot; + idSensor + &quot;' not found in http://&quot; + zibaseIP + &quot;/sensors.xml&quot;), { date : null, v1 : 0, v2 : 0 }); } }); }; function ip2long(IP) { // http://kevin.vanzonneveld.net // + original by: Waldo Malqui Silva // + improved by: Victor // + revised by: fearphage (http://http/my.opera.com/fearphage/) // + revised by: Theriault // * example 1: ip2long('192.0.34.166'); // * returns 1: 3221234342 // * example 2: ip2long('0.0xABCDEF'); // * returns 2: 11259375 // * example 3: ip2long('255.255.255.256'); // * returns 3: false var i = 0; // PHP allows decimal, octal, and hexadecimal IP components. // PHP allows between 1 (e.g. 127) to 4 (e.g 127.0.0.1) components. IP = IP.match(/^([1-9]\\d*|0[0-7]*|0x[\\da-f]+)(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?$/i); // Verify IP format. if (!IP) { return false; // Invalid format. } // Reuse IP variable for component counter. IP[0] = 0; for ( i = 1; i &lt; 5; i += 1) { IP[0] += !!((IP[i] || '').length); IP[i] = parseInt(IP[i]) || 0; } // Continue to use IP for overflow values. // PHP does not allow any component to overflow. IP.push(256, 256, 256, 256); // Recalculate overflow of last component supplied to make up for missing components. IP[4 + IP[0]] *= Math.pow(256, 4 - IP[0]); if (IP[1] &gt;= IP[5] || IP[2] &gt;= IP[6] || IP[3] &gt;= IP[7] || IP[4] &gt;= IP[8]) { return false; } return IP[1] * (IP[0] === 1 || 16777216) + IP[2] * (IP[0] &lt;= 2 || 65536) + IP[3] * (IP[0] &lt;= 3 || 256) + IP[4] * 1; } ZiBase.prototype.listenToZiBase = function(processDataMethod) { var socket = dgram.createSocket('udp4'); var self = this; self.socket = socket; socket.on(&quot;message&quot;, function(msg, rinfo) { if (msg.length &gt; 0) { var response = new ZbResponse(msg); processDataMethod.call(self, response); } }); socket.on(&quot;listening&quot;, function() { var address = socket.address(); logger.debug(&quot;socket listening on: &quot; + address.port); if (self.deregistered == false) { self.registerListener(address.port); } else { socket.close(); } }); socket.bind(); }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Global ZbActionZbProtocolZbRequestZbResponseZbVirtualProbeZiBase Global Members ZbAction Enum des actions possibles par la Zibase Source: zibase.js, line 58 ZbProtocol Enum des protocoles Zibase Source: zibase.js, line 27 ZbVirtualProbe Enum des sondes virtuelles Source: zibase.js, line 49 Methods ZbRequest() Requête spécifique pour la Zibase Source: zibase.js, line 81 ZbResponse() Réponse spécifique de la Zibase Source: zibase.js, line 159 ZiBase(string, string, string) Permet de manipuler la ZiBase.Il est nécessaire de connaître l'adresse IP de sa zibase pour l'utiliser. Parameters: Name Type Description string $ipAddr Adresse IP de la zibase string $deviceId Device de la zibase string $token Token de la zibase Source: zibase.js, line 192 × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Global ZbActionZbProtocolZbRequestZbResponseZbVirtualProbeZiBase zibaseA NodeJS API to ZiBase IntroductionThis module is a SDK to connect to a Zibase. Most of it should be working fine, as it is currently used in a real home automation installation. However, it has been tested so far only against a Zibase Classic. This SDK is strongly inspired from the PHP SDK written by Benjamin Garel. InstallationInstall as a npm module: npm install zibaseUseUse as a npm module: var zibase=require('zibase');Connection to a ZibaseIn order to communicate with a Zibase it is necessary to connect to it by instanciating the ZiBase class. For this, the IP address zibaseIP and the credentials deviceId and token of the Zibase are needed. var Zibase = new zibase.ZiBase( zibaseIP, deviceId, token);An optional callback parameter can be used to be notified once the Zibase has been recognized. var Zibase = new zibase.ZiBase( zibaseIP, deviceId, token, function () { console.log(&quot;Connection established.&quot;); });It will initialize a connexion to the Zibase, register the calling application as a client of the Zibase, letting the Zibase send its activity information to the client. The first message sent by the Zibase indicates that the registration was successful: 21/02/2016 20:32:51.929 &lt;info&gt; zibase.js:424 (ZiBase.processZiBaseData) Zapi linked to host IP=&lt;zip&gt;192.168.0.10&lt;/zip&gt; UDP Port=&lt;zudp&gt;60580&lt;/zudp&gt;DescriptorsThe descriptors of the Zibase are loaded when the ZiBase class is instanciated. They can be accessed through: the ZiBase.descriptors member:console.log(Zibase.descriptors);will produce:[ { type: 'device', name: 'Ventilation SdB', t: 'receiverXDom', i: 'logotype_airfan.png', c: 'C3' }, { type: 'device', name: 'Conso Wall Plug', t: 'power', i: 'logotype_power.png', c: 'PZA3' }, { type: 'device', name: 'Pompe à Chaleur', t: 'receiverXDom', i: 'logotype_heatpomp.png', c: 'P7', p: '5' }, { type: 'scenario', name: 'simulation intrusion', id: '9', icon: 'logoMacro_Portes.png' }, { type: 'scenario', name: 'Notification iOS', id: '16', icon: 'logoMacro_Scenario.png' } ] the ZiBase.getDescriptor(id) method:console.log(Zibase.getDescriptor(&quot;P7&quot;));will produce:{ type: 'device', name: 'Pompe à Chaleur', t: 'receiverXDom', i: 'logotype_heatpomp.png', c: 'P7', p: '5' } VariablesThe variables V0 to V31 can be read through ZiBase.getVariable: Zibase.getVariable(10, function(err, value) { if (err) console.log(err); console.log(&quot;V10=&quot; + value); });DevicesThe state of devices can be retrieved through ZiBase.getState: Zibase.getState(&quot;ZB5&quot;, function(err, value) { if (err) console.log(err); console.log(&quot;ZB5 state =&quot; + value); });SensorsThe information about a sensor can be retrieved through ZiBase.getSensorInfo: Zibase.getSensorInfo(&quot;OS439157578&quot;, function(err, value) { if (err) console.log(err); console.log(&quot;Infos =&quot; + value); });EventsThe activity of the Zibase is logged through tracer messages: 21/02/2016 22:00:48.955 &lt;info&gt; zibase.js:352 (ZiBase.processZiBaseData) Received radio ID (&lt;rf&gt;ZWAVE ZB5&lt;/rf&gt; &lt;dev&gt;Low-Power Measure&lt;/dev&gt; Total Energy=&lt;kwh&gt;121.4&lt;/kwh&gt;kWh Power=&lt;w&gt;00&lt;/w&gt;W Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;PZB5&lt;/id&gt;The ZiBase object is an event emitter that can call registered callbacks when receiving a given activity message. The supported events are: message: this event is emitted each time the Zibase sends a message change: this event is emitted each time the Zibase sends a message about a device. error: this event is emitted when a ZWAVE error message is send by the Zibase. restart: this event is emitted when the Zibase is restarting Listening to events is done with on(event, id, callback), or once(event, id, callback) in which case the event is triggered only once. The following code: Zibase.on('change', &quot;PZB5&quot;, function(msg){ console.log(msg); });will produce the following output: 21/02/2016 21:36:20.553 &lt;info&gt; zibase.js:352 (ZiBase.processZiBaseData) Received radio ID (&lt;rf&gt;ZWAVE ZB5&lt;/rf&gt; &lt;dev&gt;Low-Power Measure&lt;/dev&gt; Total Energy=&lt;kwh&gt;121.4&lt;/kwh&gt;kWh Power=&lt;w&gt;00&lt;/w&gt;W Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;PZB5&lt;/id&gt; { rf: 'ZWAVE ZB5', dev: 'Low-Power Measure', kwh: '121.4', w: '00', bat: 'Ok', id: 'PZB5' }DeconnexionWhen no more interaction with the Zibase is needed, it is recommended to deconnect from it thanks to deregisterListener(). Zibase.deregisterListener();The effect of this call is to ask the Zibase to stop sending its information. It seems the Zibase can keep track of 4 clients only. When a fifth client is registered, it will replace the oldest one, hence causing a forced deregistration of the first client. When using a single client, it usually not a problem to not call deregisterListener(). However, when using several clients connected to a single Zibase, it is highly recommended to make the call, to avoid the others from being disconnected. A good practice is to use the following code: function exitHandler() { Zibase.deregisterListener(); console.log(&quot;Deregistered from Zibase.&quot;); } process.on('exit', exitHandler); process.on('SIGINT', exitHandler); process.on('uncaughtException', exitHandler); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
