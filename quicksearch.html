<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"zibase.js.html":{"id":"zibase.js.html","title":"Source: zibase.js","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Source: zibase.js //heaviliy inpspired from Benjamin Garel's PHP SDK, located in // http://bgarel.free.fr/Zibase/ var http = require(&quot;http&quot;); var request = require(&quot;request&quot;); var net = require(&quot;net&quot;); var url = require(&quot;url&quot;); var dgram = require(&quot;dgram&quot;); var util = require(&quot;util&quot;); var events = require(&quot;events&quot;); var assert = require(&quot;assert&quot;); var logger = require(&quot;tracer&quot;).colorConsole({ transport : function (data) { console.log(data.output); if (exports.test_logger == true) { exports.test_logger_data = data; } }, dateformat : &quot;dd/mm/yyyy HH:MM:ss.l&quot;, level : 3 //0:'test', 1:'trace', 2:'debug', 3:'info', 4:'warn', 5:'error' }); /** * Zibase protocols * @namespace */ var ZbProtocol = new function () { /** * @constant */ this.PRESET = 0; /** * @constant */ this.VISONIC433 = 1; /** * @constant */ this.VISONIC868 = 2; /** * @constant */ this.CHACON = 3; /** * @constant */ this.DOMIA = 4; /** * @constant */ this.X10 = 5; /** * @constant */ this.ZWAVE = 6; /** * @constant */ this.RFS10 = 7; /** * @constant */ this.X2D433 = 8; /** * @constant */ this.X2D433ALRM = 8; /** * @constant */ this.X2D868 = 9; /** * @constant */ this.X2D868ALRM = 9; /** * @constant */ this.X2D868INSH = 10; /** * @constant */ this.X2D868PIWI = 11; /** * @constant */ this.X2D868BOAC = 12; }; exports.ZbProtocol = ZbProtocol; /** * Virtual probes * @namespace */ var ZbVirtualProbe = new function () { /** * @constant */ this.OREGON = 17; /** * @constant */ this.OWL = 20; }; /** * Possible actions of the Zibase * @namespace */ var ZbAction = new function () { /** * @constant */ this.OFF = 0; /** * @constant */ this.ON = 1; /** * @constant */ this.DIM_BRIGHT = 2; /** * @constant */ this.ALL_LIGHTS_ON = 4; /** * @constant */ this.ALL_LIGHTS_OFF = 5; /** * @constant */ this.ALL_OFF = 6; /** * @constant */ this.ASSOC = 7; }; exports.ZbAction = ZbAction; /* * Possible states of alerts in the Zibase * @namespace var ZbEventType = new function () { this.OFF = 9; this.ON = 4; }; exports.ZbEventType = ZbEventType; */ /** * Creates an empty request. * @param {string} description Description of the request, which is useful for error tracking and debugging. * @class Handles requests to the Zibase */ function ZbRequest(description) { this.description = description; this.header = &quot;ZSIG&quot;; this.command = 0; this.reserved1 = &quot;&quot;; this.zibaseId = &quot;&quot;; this.reserved2 = &quot;&quot;; this.param1 = 0; this.param2 = 0; this.param3 = 0; this.param4 = 0; this.myCount = 0; this.yourCount = 0; this.message = null; } /** * Formats the request into a binary array understandable by the Zibase. * @return {Buffer} Binary array */ ZbRequest.prototype.toBinaryArray = function() { var header = new Buffer(this.header); var command = new Buffer(2) command.writeUInt16BE(this.command, 0); var reserved1 = new Buffer(16); reserved1.fill(String.fromCharCode(0)); reserved1.write(this.reserved1); var zibaseId = new Buffer(16); zibaseId.fill(String.fromCharCode(0)); zibaseId.write(this.zibaseId); var reserved2 = new Buffer(12); reserved2.fill(String.fromCharCode(0)); reserved2.write(this.reserved2); var param1 = new Buffer(4); param1.writeUInt32BE(this.param1, 0); var param2 = new Buffer(4); param2.writeUInt32BE(this.param2, 0); var param3 = new Buffer(4); param3.writeUInt32BE(this.param3, 0); var param4 = new Buffer(4); param4.writeUInt32BE(this.param4, 0); var myCount = new Buffer(2); myCount.writeUInt16BE(this.myCount, 0); var yourCount = new Buffer(2); yourCount.writeUInt16BE(this.yourCount, 0); var data; if (this.message != null) { var message = new Buffer(96); message.fill(String.fromCharCode(0)); message.write(this.message); data = Buffer.concat([header, command, reserved1, zibaseId, reserved2, param1, param2, param3, param4, myCount, yourCount, message]); } else { data = Buffer.concat([header, command, reserved1, zibaseId, reserved2, param1, param2, param3, param4, myCount, yourCount]); } logger.debug(data) return data; } /** * Creates a response from the binary data sent by the Zibase * @class Handles responses from the Zibase * @param {Buffer} buffer Binary data */ function ZbResponse(buffer) { var tempString = &quot;&quot;; this.header = buffer.toString('utf8', 0, 4); this.command = buffer.readUInt16BE(4); tempString = buffer.toString('utf8', 6, 21); this.reserved1 = tempString.substr(0, tempString.indexOf('\\u0000')); tempString = buffer.toString('utf8', 22, 37); this.zibaseId = tempString.substr(0, tempString.indexOf('\\u0000')); tempString = buffer.toString('utf8', 38, 49); this.reserved2 = tempString.substr(0, tempString.indexOf('\\u0000')); this.param1 = buffer.readUInt32BE(50); this.param2 = buffer.readUInt32BE(54); this.param3 = buffer.readUInt32BE(58); this.param4 = buffer.readUInt32BE(62); this.myCount = buffer.readUInt16BE(64); this.yourCount = buffer.readUInt16BE(66); tempString = buffer.toString('utf8', 70); this.message = tempString.substr(0, tempString.indexOf('\\u0000')); }; /** * * @class Allows to manipulate the zibase. The IP of the zibase is needed. * @param {string} ipAddr IP address of the zibase * @param {string} deviceId Device ID of the zibase * @param {string} token Token of the zibase * @param {function} callback Callback to call when the connection to the zibase is established. * @extends events.EventEmitter */ function ZiBase(ipAddr, deviceId, token, callback) { this.ip = ipAddr; this.port = 49999; this.localport = undefined; this.myip = require(&quot;ip&quot;).address(); this.deregistered = false; // true if deregistration has been requested this.deviceId = deviceId; this.token = token; this.timeZone = &quot;Europe/Paris&quot;; events.EventEmitter.call(this); this.emitEvent = function(event, arg1, arg2) { if (arg2) { var id = arg1; var arg = arg2; this.emit(event + &quot;:&quot; + id, arg); } else { this.emit(event, arg1); } } var self = this; this.loadDescriptors(function(err) { self.listenToZiBase(self.processZiBaseData); if (callback) callback(err); }); } util.inherits(ZiBase, events.EventEmitter); exports.ZiBase = ZiBase; /** * Loads the descriptors of declared devices and scenarios * @param {function} cb Callback to be called when the descriptors are loaded */ ZiBase.prototype.loadDescriptors = function(cb) { this.descriptors = []; this.descriptorsByID = []; var self = this; request.get(&quot;https://zibase.net/m/get_xml.php?device=&quot; + this.deviceId + &quot;&amp;token=&quot; + this.token, function(error, response, bodyString) { if (error) { cb(error); return; } if (bodyString == &quot;&quot;) { cb(new Error(&quot;Cannot load descriptors, empty response from https://zibase.net/m/get_xml.php?device=XXX&amp;token=XXX&quot;)); return; } var re = /&lt;([m|e])\\s+([^&gt;]*)&gt;\\s*&lt;n&gt;([^&lt;]*)&lt;\\/n&gt;\\s*&lt;\\/[m|e]&gt;/g; var match; while (( match = re.exec(bodyString)) != undefined) { var type=match[1]; var props=match[2]; var name=match[3]; var desc = {}; switch(type) { case 'e': desc.type = &quot;device&quot;; break; case 'm': desc.type = &quot;scenario&quot;; break; default: desc.type = &quot;&quot;; logger.error(&quot;unexpected type '&quot; + type + &quot;' from zibase descriptors, 'e' or 'm' expected.&quot;); break; } desc.name = name; var rep = /([^=]+)=&quot;([^&quot;]*)&quot;\\s*/g; var matchp; while (( matchp = rep.exec(props)) != undefined) { var id = matchp[1]; var value = matchp[2]; desc[id] = value; } self.descriptors.push(desc); var id = desc.type == &quot;device&quot;?&quot;c&quot;:&quot;id&quot;; assert.notEqual(desc[id], undefined); if (desc.type == &quot;device&quot; &amp;&amp; desc.p == 6) { // ZWave self.descriptorsByID[&quot;Z&quot; + desc[id]] = desc; } else self.descriptorsByID[desc[id]] = desc; } cb(null); }); } /** * retrieves the descriptor with a given id * @param {string} id ID of the descriptor to retrieve */ ZiBase.prototype.getDescriptor = function(id) { return this.descriptorsByID[id]; } /** * listens to events * @param {string} event Event to be listened to * @param {string} [id] The ID of the device that triggers the event. Don't specify any when the event is triggered by the zibase * @param {function} callback Callback to be called when the event is triggered. The parameters of the callback depend on the event */ ZiBase.prototype.on = function(event, id, callback) { if (( typeof event === 'string') &amp;&amp; ( typeof id === 'string') &amp;&amp; ( typeof callback === 'function')) { event = event + &quot;:&quot; + id } if (( typeof event === 'string') &amp;&amp; ( typeof id === 'function') &amp;&amp; ( typeof callback === 'undefined')) { callback = id } ZiBase.super_.prototype.on.call(this, event, callback); } /** * same as method &lt;tt&gt;on&lt;/tt&gt; but only for one event * @see Zibase#on * @param {string} event Event to be listened to * @param {string} [id] The ID of the device that triggers the event. Don't specify any when the event is triggered by the zibase * @param {function} callback Callback to be called when the event is triggered. The parameters of the callback depend on the event */ ZiBase.prototype.once = function(event, id, callback) { if (( typeof event === 'string') &amp;&amp; ( typeof id === 'string') &amp;&amp; ( typeof callback === 'function')) { // normal call event = event + &quot;:&quot; + id } if (( typeof event === 'string') &amp;&amp; ( typeof id === 'function') &amp;&amp; ( typeof callback === 'undefined')) { callback = id } ZiBase.super_.prototype.once.call(this, event, callback); //logger.error(this) } /** * process the information messages sent by the zibase. * Emits events depending on the content of the response. * @param {Response} response A response to process, as sent by the zibase */ ZiBase.prototype.processZiBaseData = function(response) { //response.message = &quot;Received radio ID (&lt;rf&gt;433Mhz&lt;/rf&gt; Noise=&lt;noise&gt;2090&lt;/noise&gt; Level=&lt;lev&gt;2.3&lt;/lev&gt;&lt;id&gt;OS3930858754&lt;/id&gt;&quot; if (response.reserved1 == &quot;TEXTMSG&quot;) { function replaceid(zb, message, entire_string, id, before, id_modified, after){ var name; var desc = zb.descriptorsByID[id]; if (desc != undefined) name = desc.name; if (name != undefined) { return message.replace(entire_string, before+id_modified+&quot; (&quot;+name+&quot;)&quot;+after); } return message; } var infos = {}; //Received radio ID (&lt;rf&gt;ZWAVE ZA5&lt;/rf&gt; &lt;dev&gt;CMD/INTER&lt;/dev&gt; Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;ZA5_OFF&lt;/id&gt; if (/Received radio ID \\(.*CMD\\/INTER/.test(response.message)) { var re = /([^:]+:\\s*&lt;id&gt;)(([^_]+)(_OFF)?)(&lt;\\/id&gt;)/; if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = (match[4] == undefined) ? &quot;ON&quot; : &quot;OFF&quot; } var msg =replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; match[5] // end ); logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //Received radio ID (&lt;rf&gt;433Mhz&lt;/rf&gt; Noise=&lt;noise&gt;2175&lt;/noise&gt; Level=&lt;lev&gt;2.3&lt;/lev&gt;/5 &lt;dev&gt;Oregon THWR288A-THN132N&lt;/dev&gt; Ch=&lt;ch&gt;2&lt;/ch&gt; T=&lt;tem&gt;+3.7&lt;/tem&gt;°C (+38.6°F) Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;OS3930858754&lt;/id&gt; else if (/Received radio ID \\(/.test(response.message)) { var re = /&lt;([^&gt;]+)&gt;([^&lt;]*)&lt;\\/(\\1)&gt;/g while (( match = re.exec(response.message)) != null) { logger.trace(match); infos[match[1]] = match[2]; } var trace = replaceid(this, response.message, &quot;&lt;id&gt;&quot; + infos[&quot;id&quot;] + &quot;&lt;/id&gt;&quot;, // entire string infos[&quot;id&quot;], // ID &quot;&lt;id&gt;&quot;, // start infos[&quot;id&quot;], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&lt;/id&gt;&quot; // end ); re = /(&lt;rf&gt;ZWAVE )([^&lt;]+)(&lt;\\/rf&gt;)/; if ((match = re.exec(trace)) != null) { trace = replaceid(this, trace, match[0], // entire string match[2], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; match[3] // end ); } logger.info(trace); this.emitEvent(&quot;message&quot;, {message: trace, raw_message: response.reserved1}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //Sent radio ID (1 Burst(s), Protocols='Family http' ): I5_OFF else if (/Sent radio ID \\(/.test(response.message)) { var msg; var re = /([^:]+:\\s*)(([^_]+)(_OFF|_ON)?)/ if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = (match[4] == &quot;_OFF&quot;) ? &quot;OFF&quot; : &quot;ON&quot; msg=replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); logger.info(msg); } else { msg=response.message; logger.error(&quot;Error, regexp &quot; + re + &quot; not found in response.message!&quot;); logger.info(response.message); } this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); logger.trace(&quot;infos=&quot;, infos) if (infos.id != undefined) { this.emitEvent(&quot;change&quot;, infos.id, infos) } } //ZWave warning - Device ZA8 is unreachable! : ERR_ZA8 else if (/ZWave warning.*ERR_/.test(response.message)) { var re = /([^:]+:\\s*)(ERR_([^_]+))/; var msg; if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[3]; infos.value = &quot;ERR&quot;; logger.debug(infos); logger.debug(match); msg=replaceid(this, response.message, match[0], // entire string match[3], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); } else { msg=response.message; logger.error(&quot;Error, regexp &quot; + re + &quot; not found in response.message!&quot;); } logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); if (infos.id != undefined) { this.emitEvent(&quot;error&quot;, infos.id, infos) } } // ZWave warning - Device ZP16 is unknown! else if (/ZWave warning.*unknown/.test(response.message)) { var re = /(.*Device\\s*)([A-Z]+[0-9]+)/; var msg; if (( match = re.exec(response.message)) != null) { logger.trace(match); infos.id = match[2]; infos.value = &quot;ERR&quot;; logger.debug(infos); logger.debug(match); msg=replaceid(this, response.message, match[0], // entire string match[2], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); } else { msg=response.message; logger.error(&quot;Error, regexp &quot; + re + &quot; not found in response.message!&quot;); } logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); if (infos.id != undefined) { this.emitEvent(&quot;error&quot;, infos.id, infos) } } // Completed SCENARIO: 45 else if (/(Completed|Launch) SCENARIO:/.test(response.message)) { var re = /(SCENARIO: )([0-9]+)/; if (( match = re.exec(response.message)) != null) { logger.trace(match); } var msg=replaceid(this, response.message, match[0], // entire string match[2], // ID match[1], // start match[2], // &quot;ID modified&quot; to be replaced by &quot;ID modified (name)&quot; &quot;&quot; // end ); logger.info(msg); this.emitEvent(&quot;message&quot;, {message: msg, raw_message: response.message}); } else { logger.info(response.message); this.emitEvent(&quot;message&quot;, {message: response.message, raw_message: response.message}); } } else if (response.reserved1 == &quot;SLAMSIG&quot;) { this.emitEvent(&quot;restart&quot;); // zibase is restarting // let's reinit self = this; this.loadDescriptors(function (err) { // deregister first, just in case self.deregisterListener(); // then re-listen to zibase self.deregistered = false; self.listenToZiBase(self.processZiBaseData); }); } else { logger.warn(&quot;Unsupported response:&quot;, response) } }; var messageQueue = []; function nextCallback() { logger.debug(&quot;nextCallback called&quot;) // removing previous request, which has been handled messageQueue.shift(); // check if still a message to process if (messageQueue.length &gt; 0) { logger.debug(&quot;queue not empty; processing&quot;) var callback = messageQueue[0]; logger.debug(callback) callback(); } }; function pushRequest(requestFunc) { logger.debug(&quot;pushing request&quot;) messageQueue.push(requestFunc) if (messageQueue.length === 1) { logger.debug(&quot;queue was empty, processing&quot;) requestFunc() } else { logger.debug(&quot;queue not empty, waiting&quot;) } } /** * Sends a request to the zibase * @param {ZbRequest} request Request to be sent * @param {boolean} withResponse Indicates if a response is to be expected * @param {function} callback Callback to be called when the response is received */ ZiBase.prototype.sendRequest = function(request, withResponse, callback) { logger.debug('request=', request); if (withResponse == undefined) { withResponse = true } var self = this; pushRequest(function executeRequest () { var socket = dgram.createSocket('udp4'); var time_sent; // time at which request is sent var time_received; // time at which response is received if (withResponse) { var t = setTimeout(function() { var address = socket.address(); socket.close(); if (!request.inRetryMode) { request.inRetryMode = true; logger.warn(&quot;socket timeout for request '&quot; + request.description + &quot;'. Retrying...&quot;); // nextCallback(); // unpile the current call // and try again // self.sendRequest(request, withResponse, callback); executeRequest(); } else { var err = new Error(&quot;socket timeout while waiting for response on &quot; + address.port + &quot;, request was: '&quot; + request.description + &quot;'.&quot;); callback(err, undefined) } nextCallback(); }, 5 * 1000); // 5 seconds x 2 retries = 10 s socket.on(&quot;message&quot;, function(msg, rinfo) { clearTimeout(t); logger.trace(&quot;socket got: &quot; + msg + &quot; from &quot; + rinfo.address + &quot;:&quot; + rinfo.port); var response = null; if (msg.length &gt; 0) { time_received = new Date(); response = new ZbResponse(msg); logger.trace(&quot;response to request '&quot; + request.description + &quot;' received after &quot; + ((time_received - time_sent)/1000) + &quot;s=&quot;, response) callback(null, response); } logger.debug(&quot;socket closing &quot; + socket.address().port); socket.close(); nextCallback(); }); socket.on(&quot;listening&quot;, function() { var address = socket.address(); logger.debug(&quot;socket listening from SendRequest on &quot; + address.port); }); socket.on(&quot;error&quot;, function() { var address = socket.address(); logger.error(&quot;socket error on port &quot; + address.port); nextCallback(); }); socket.bind(); } var buffer = request.toBinaryArray(); time_sent = new Date(); socket.send(buffer, 0, buffer.length, self.port, self.ip, function(err, bytes) { logger.trace(&quot;buffer.length=&quot;, buffer.length); logger.trace(&quot;err=&quot;, err); logger.trace(&quot;bytes=&quot;, bytes); logger.trace(&quot;fin&quot;); if (!withResponse) { logger.debug(&quot;socket closing &quot; + socket.address().port); socket.close(); nextCallback(); } }); }); }; /** * Ask the zibase to send a command to an activator specified by its ID and protocol * @param {string} address Address of the activator in X10 format (e.g. B5) * @param {ZbAction} action Action to execute * @param {ZbProtocol} protocol Protocol RF to be used * @param {int} dimLevel Not supported by the Zibase for now * @param {int} nbBurst Number of RF emissions */ ZiBase.prototype.sendCommand = function(address, action, protocol, dimLevel, nbBurst) { logger.debug(&quot;params:&quot;, address, action, protocol, dimLevel, nbBurst) if (protocol == undefined) { protocol = ZbProtocol.PRESET } if (dimLevel == undefined) { dimLevel = 0 } if (nbBurst == undefined) { nbBurst = 1 } var description = &quot;sendCommand(&quot; + address + &quot; &quot; + action + &quot;...)&quot; ; if (/^[zZ]?[a-pA-P]([1-9]|1[0-6])$/.test(address)) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { address = address.substr(1); protocol = ZbProtocol.ZWAVE; } var request = new ZbRequest(description); request.command = 11; if (action == ZbAction.DIM_BRIGHT &amp;&amp; dimLevel == 0) action = ZbAction.OFF; request.param2 = action; logger.debug(&quot;action = &quot;, action) request.param2 |= (protocol &amp; 0xFF) &lt;&lt; 0x08; if (action == ZbAction.DIM_BRIGHT) request.param2 |= (dimLevel &amp; 0xFF) &lt;&lt; 0x10; if (nbBurst &gt; 1) request.param2 |= (nbBurst &amp; 0xFF) &lt;&lt; 0x18; request.param3 = 0 + address.substr(1) - 1; request.param4 = address.charCodeAt(0) - 0x41; this.sendRequest(request, true, function(response) { logger.debug(&quot;response from Zibase = &quot;, response); }); } else { throw new Error(&quot;address must be (Z)[A-P]1-16.&quot;) } }; /** * Asks the zibase to run the scenario specified by its number * @param {int|string} scenario the scenario number or name * @returns {boolean} false if scenario doesn't resolve to a scenario number */ ZiBase.prototype.runScenario = function(scenario) { logger.info(&quot;runScenario&quot;, scenario); var request = new ZbRequest(&quot;runScenario(&quot; + scenario + &quot;)&quot;); request.command = 11; request.param1 = 1; var numScenario; if (typeof scenario == 'number') { numScenario = scenario; } else { for (var d in this.descriptors) { if (this.descriptors[d].type == &quot;scenario&quot; &amp;&amp; this.descriptors[d].name == scenario) { numScenario = parseInt(this.descriptors[d].id); break; } } } if (typeof numScenario != 'number') { logger.error(&quot;Error: unknown scenario '&quot; + JSON.stringify(scenario) + &quot;'. Maybe the scenario is not visible in Zibase?&quot;); return false; } request.param2 = numScenario; this.sendRequest(request, true, function(response) { logger.info(&quot;response from Zibase = &quot;, response); }); return true; } /** * Positions a Zibase alert to the state ON or OFF, or simulates a sensor ID message in the activity log of the Zibase * @param {int} action The action: 0 - deactivate an alert, 1 - activate an alert, 2 - simulate a sensor ID message (can trigger the execution of a scenario) * @param {string} address Address of the activator in X10 format (e.g. B5 or ZA14) */ ZiBase.prototype.setEvent = function(action, address) { logger.info(&quot;setEvent&quot;, action, address); var request = new ZbRequest(&quot;setEvent(&quot; + address + &quot; &quot; + action + &quot;)&quot;); request.command = 11; request.param1 = 4; request.param2 = action; var ev_type; if (action == 0) { ev_type = 9 } if (action == 1 || action == 2) { ev_type = 4 } var protocol; if (address.length &gt; 1) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { address = address.substr(1); protocol = ZbProtocol.ZWAVE; } var letter = address.charCodeAt(0) - 0x41; var device = 0 + address.substr(1) - 1; var id = letter * 16 + device } request.param3 = id; if (protocol == ZbProtocol.ZWAVE) { if (ev_type == 4) ev_type = 19 if (ev_type == 9) ev_type = 20 } request.param4 = ev_type; this.sendRequest(request, false, function(response) { logger.info(&quot;response from Zibase = &quot;, response); }); } /** * Get the value of a Vx variable of the Zibase * @param {int} numVar number of the variable (0 to 31) * @param {function} callback Callback to be called when the value is retrieved */ ZiBase.prototype.getVariable = function(numVar, callback) { logger.trace(&quot;entering getVariable&quot;, numVar); var request = new ZbRequest(&quot;getVariable(&quot; + numVar + &quot;)&quot;); request.command = 11; request.param1 = 5; request.param3 = 0; request.param4 = numVar; this.sendRequest(request, true, function(err, response) { logger.debug(&quot;getVariable&quot;, numVar, &quot;=&gt; err=&quot;, err, &quot;value=&quot;, (response != null) ? response.param1 : null); callback(err, (response != null) ? response.param1 : null); }); } /** * Asks the Zibase to register the caller client as a listener. * After this call, the Zibase will send its activity log to the caller, on the given port. * @param {int} port The port to listen in order to receive the messages */ ZiBase.prototype.registerListener = function(port) { this.localport = port; var ip = this.myip; logger.debug(&quot;registerListener&quot;, ip, port); var request = new ZbRequest(&quot;registerListener(&quot; + ip + &quot; &quot; + port + &quot;)&quot;); request.command = 13; request.param1 = ip2long(ip); request.param2 = port; request.param3 = 0; request.param4 = 0; this.sendRequest(request, false); }; /** * Asks the Zibase to unregister the caller client */ ZiBase.prototype.deregisterListener = function() { logger.debug(&quot;deregisterListener&quot;, this.myip, this.localport); this.deregistered = true; if (this.socket != undefined) { this.socket.close(); this.socket = undefined; } var request = new ZbRequest(&quot;deregisterListener(&quot; + this.myip + &quot; &quot; + this.localport + &quot;)&quot;); request.command = 22; request.param1 = ip2long(this.myip); request.param2 = this.localport; request.param3 = 0; request.param4 = 0; this.sendRequest(request, false); }; /** * Gets the state of an activator from the Zibase * @param {string} adress X10 formatted address of the activator * @param {function} callback Callback to be called when the state is received */ ZiBase.prototype.getState = function(address, callback) { logger.trace(&quot;getState&quot;, address); var description = &quot;getState(&quot; + address + &quot;)&quot;; var isZWave = false; if (address.length &gt; 1) { address = address.toUpperCase(); if (address[0] == &quot;Z&quot;) { isZWave = true; address = address.substr(1); } } if (address.length &gt; 1) { var request = new ZbRequest(description); request.command = 11; request.param1 = 5; request.param3 = 4; var houseCode = address.charCodeAt(0) - 0x41; var device = 0 + address.substr(1) - 1; request.param4 = device; request.param4 |= (houseCode &amp; 0x0F) &lt;&lt; 0x04; // Pour le zwave, il faut mettre le 9e bit à 1 if (isZWave) request.param4 |= 0x0100; this.sendRequest(request, true, function(err, response) { logger.debug(&quot;getState&quot;, address, &quot;=&gt; err=&quot;, err, &quot;value=&quot;, (response != null) ? response.param1 : null); callback(err, (response != null) ? response.param1 : null); }); } }; /** * retrieves the information about a given sensor * @param {string} idSensor ID of the sensor * @param {function} callback Callback to be called when the info is retrieved */ ZiBase.prototype.getSensorInfo = function(idSensor, callback) { var typeSensor = idSensor.substring(0, 2); var numberSensor = idSensor.substring(2, 10000); var zibaseIP = this.ip; var self = this; var singleTimeout = 1000; // timeout of a single request var timeout = 15000; // global timeout var start = Date.now(); function getAndProcess () { var singleStart = Date.now(); request.get(&quot;http://&quot; + zibaseIP + &quot;/sensors.xml&quot;, {timeout: singleTimeout}, function(err, response, bodyString) { if (err) { if (Date.now() - start &gt; timeout) { logger.error(err); callback(err); } else { var delay = singleTimeout - (Date.now() - singleStart); if (delay &lt;= 0) { getAndProcess(); } else { setTimeout(function () { getAndProcess(); }, delay); } } return; } var re = new RegExp('&lt;ev type=&quot;([^&quot;]*)&quot; +pro=&quot;' + typeSensor + '&quot; +id=&quot;' + numberSensor + '&quot; +gmt=&quot;([^&quot;]*)&quot; +v1=&quot;([^&quot;]*)&quot; +v2=&quot;([^&quot;]*)&quot; +lowbatt=&quot;([^&quot;]*)&quot;/&gt;', &quot;g&quot;); var match; if (( match = re.exec(bodyString)) != undefined) { for ( i = 1; i &lt; match.length; i++) { var to = match[i]; logger.trace(to); } var type = match[1]; // var pro = match[2]; // var id = match[3]; var gmt = match[2]; var v1 = match[3]; var v2 = match[4]; var lowbat = match[5]; // create a new javascript Date object based on the timestamp // multiplied by 1000 so that the argument is in milliseconds, not seconds var date = new Date(gmt * 1000); // hours part from the timestamp var hours = date.getHours(); // minutes part from the timestamp var minutes = date.getMinutes(); // seconds part from the timestamp var seconds = date.getSeconds(); logger.trace(&quot;date=&quot;, date); logger.trace(&quot;v1=&quot;, v1); logger.trace(&quot;v2=&quot;, v2); var results = new Object results.date = date results.v1 = v1 results.v2 = v2 callback(null, results); } else { // found nothing callback(new Error(&quot;idSensor '&quot; + idSensor + &quot;' not found in http://&quot; + zibaseIP + &quot;/sensors.xml&quot;), { date : null, v1 : 0, v2 : 0 }); } }); } getAndProcess(); }; function ip2long(IP) { // http://kevin.vanzonneveld.net // + original by: Waldo Malqui Silva // + improved by: Victor // + revised by: fearphage (http://http/my.opera.com/fearphage/) // + revised by: Theriault // * example 1: ip2long('192.0.34.166'); // * returns 1: 3221234342 // * example 2: ip2long('0.0xABCDEF'); // * returns 2: 11259375 // * example 3: ip2long('255.255.255.256'); // * returns 3: false var i = 0; // PHP allows decimal, octal, and hexadecimal IP components. // PHP allows between 1 (e.g. 127) to 4 (e.g 127.0.0.1) components. IP = IP.match(/^([1-9]\\d*|0[0-7]*|0x[\\da-f]+)(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?(?:\\.([1-9]\\d*|0[0-7]*|0x[\\da-f]+))?$/i); // Verify IP format. if (!IP) { return false; // Invalid format. } // Reuse IP variable for component counter. IP[0] = 0; for ( i = 1; i &lt; 5; i += 1) { IP[0] += !!((IP[i] || '').length); IP[i] = parseInt(IP[i]) || 0; } // Continue to use IP for overflow values. // PHP does not allow any component to overflow. IP.push(256, 256, 256, 256); // Recalculate overflow of last component supplied to make up for missing components. IP[4 + IP[0]] *= Math.pow(256, 4 - IP[0]); if (IP[1] &gt;= IP[5] || IP[2] &gt;= IP[6] || IP[3] &gt;= IP[7] || IP[4] &gt;= IP[8]) { return false; } return IP[1] * (IP[0] === 1 || 16777216) + IP[2] * (IP[0] &lt;= 2 || 65536) + IP[3] * (IP[0] &lt;= 3 || 256) + IP[4] * 1; } ZiBase.prototype.listenToZiBase = function(processDataMethod) { var socket = dgram.createSocket('udp4'); var self = this; self.socket = socket; socket.on(&quot;message&quot;, function(msg, rinfo) { if (msg.length &gt; 0) { var response = new ZbResponse(msg); processDataMethod.call(self, response); } }); socket.on(&quot;listening&quot;, function() { var address = socket.address(); logger.debug(&quot;socket listening on: &quot; + address.port); if (self.deregistered == false) { self.registerListener(address.port); } else { socket.close(); self.socket = undefined; } }); socket.bind(); }; ZiBase.prototype.executeRemote = function(id, action) { request.get(&quot;https://zibase.net/api/get/ZAPI.php?zibase=&quot; + this.deviceId + &quot;&amp;token=&quot; + this.token + &quot;&amp;service=execute&amp;target=remote&amp;id=&quot; + id + &quot;&amp;action=&quot; + action, function(error, response, bodyString) { if (error) logger.error(error); if (!/&quot;head&quot; : &quot;success&quot;/.test(bodyString)) { logger.error(&quot;executeRemote(&quot; + id + &quot;) failed. Response=&quot; + bodyString); } }); } × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Classes Classes ZbRequest ZbResponse ZiBase Namespaces ZbAction ZbProtocol ZbVirtualProbe × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Namespaces Classes ZbRequest ZbResponse ZiBase Namespaces ZbAction ZbProtocol ZbVirtualProbe × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase zibaseA NodeJS API to ZiBase IntroductionThis module is a SDK to connect to a Zibase. Most of it should be working fine, as it is currently used in a real home automation installation. However, it has been tested so far only against a Zibase Classic. This SDK is strongly inspired from the PHP SDK written by Benjamin Garel. InstallationInstall as a npm module: npm install zibaseUsageUse as a npm module: var zibase = require('zibase');Connection to a ZibaseIn order to communicate with a Zibase it is necessary to connect to it by instanciating the ZiBase class. For this, the IP address zibaseIP and the credentials deviceId and token of the Zibase are needed. var Zibase = new zibase.ZiBase( zibaseIP, deviceId, token);An optional callback parameter can be used to be notified once the Zibase has been recognized. var Zibase = new zibase.ZiBase( zibaseIP, deviceId, token, function (err) { if (err) console.log(err); else console.log(&quot;Connection established.&quot;); });It will initialize a connexion to the Zibase, register the calling application as a client of the Zibase, letting the Zibase send its activity information to the client. The first message sent by the Zibase indicates that the registration was successful: 21/02/2016 20:32:51.929 &lt;info&gt; zibase.js:424 (ZiBase.processZiBaseData) Zapi linked to host IP=&lt;zip&gt;192.168.0.10&lt;/zip&gt; UDP Port=&lt;zudp&gt;60580&lt;/zudp&gt;DescriptorsThe descriptors of the Zibase are loaded when the ZiBase class is instanciated. They can be accessed through: the ZiBase.descriptors member:console.log(Zibase.descriptors);will produce:[ { type: 'device', name: 'Ventilation SdB', t: 'receiverXDom', i: 'logotype_airfan.png', c: 'C3' }, { type: 'device', name: 'Conso Wall Plug', t: 'power', i: 'logotype_power.png', c: 'PZA3' }, { type: 'device', name: 'Pompe à Chaleur', t: 'receiverXDom', i: 'logotype_heatpomp.png', c: 'P7', p: '5' }, { type: 'scenario', name: 'simulation intrusion', id: '9', icon: 'logoMacro_Portes.png' }, { type: 'scenario', name: 'Notification iOS', id: '16', icon: 'logoMacro_Scenario.png' } ] the ZiBase.getDescriptor(id) method:console.log(Zibase.getDescriptor(&quot;P7&quot;));will produce:{ type: 'device', name: 'Pompe à Chaleur', t: 'receiverXDom', i: 'logotype_heatpomp.png', c: 'P7', p: '5' } VariablesThe variables V0 to V31 can be read through ZiBase.getVariable: Zibase.getVariable(10, function(err, value) { if (err) console.log(err); console.log(&quot;V10=&quot; + value); });DevicesThe state of devices can be retrieved through ZiBase.getState: Zibase.getState(&quot;ZB5&quot;, function(err, value) { if (err) console.log(err); console.log(&quot;ZB5 state =&quot; + value); });SensorsThe information about a sensor can be retrieved through ZiBase.getSensorInfo: Zibase.getSensorInfo(&quot;OS439157578&quot;, function(err, value) { if (err) console.log(err); console.log(&quot;Infos =&quot; + value); });EventsThe activity of the Zibase is logged through tracer messages: 21/02/2016 22:00:48.955 &lt;info&gt; zibase.js:352 (ZiBase.processZiBaseData) Received radio ID (&lt;rf&gt;ZWAVE ZB5&lt;/rf&gt; &lt;dev&gt;Low-Power Measure&lt;/dev&gt; Total Energy=&lt;kwh&gt;121.4&lt;/kwh&gt;kWh Power=&lt;w&gt;00&lt;/w&gt;W Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;PZB5&lt;/id&gt;The ZiBase object is an event emitter that can call registered callbacks when receiving a given activity message. The supported events are: message: this event is emitted each time the Zibase sends a message change: this event is emitted each time the Zibase sends a message about a device. error: this event is emitted when a ZWAVE error message is send by the Zibase. restart: this event is emitted when the Zibase is restarting Listening to events is done with on(event, id, callback), or once(event, id, callback) in which case the event is triggered only once. The following code: Zibase.on('change', &quot;PZB5&quot;, function(msg){ console.log(msg); });will produce the following output: 21/02/2016 21:36:20.553 &lt;info&gt; zibase.js:352 (ZiBase.processZiBaseData) Received radio ID (&lt;rf&gt;ZWAVE ZB5&lt;/rf&gt; &lt;dev&gt;Low-Power Measure&lt;/dev&gt; Total Energy=&lt;kwh&gt;121.4&lt;/kwh&gt;kWh Power=&lt;w&gt;00&lt;/w&gt;W Batt=&lt;bat&gt;Ok&lt;/bat&gt;): &lt;id&gt;PZB5&lt;/id&gt; { rf: 'ZWAVE ZB5', dev: 'Low-Power Measure', kwh: '121.4', w: '00', bat: 'Ok', id: 'PZB5' }DeconnexionWhen no more interaction with the Zibase is needed, it is recommended to deconnect from it thanks to deregisterListener(). Zibase.deregisterListener();The effect of this call is to ask the Zibase to stop sending its information. It seems the Zibase can keep track of 4 clients only. When a fifth client is registered, it will replace the oldest one, hence causing a forced deregistration of the first client. When using a single client, it usually not a problem to not call deregisterListener(). However, when using several clients connected to a single Zibase, it is highly recommended to make the call, to avoid the others from being disconnected. A good practice is to use the following code: function exitHandler() { Zibase.deregisterListener(); console.log(&quot;Deregistered from Zibase.&quot;); } process.on('exit', exitHandler); process.on('SIGINT', exitHandler); process.on('uncaughtException', exitHandler);DocumentationA more detailed JSDoc generated documentation can be found here. × Search results Close "},"ZbAction.html":{"id":"ZbAction.html","title":"Namespace: ZbAction","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Namespace: ZbAction ZbAction Possible actions of the Zibase Source: zibase.js, line 78 Members &lt;constant&gt; ALL_LIGHTS_OFF Source: zibase.js, line 88 &lt;constant&gt; ALL_LIGHTS_ON Source: zibase.js, line 86 &lt;constant&gt; ALL_OFF Source: zibase.js, line 90 &lt;constant&gt; ASSOC Source: zibase.js, line 92 &lt;constant&gt; DIM_BRIGHT Source: zibase.js, line 84 &lt;constant&gt; OFF Source: zibase.js, line 80 &lt;constant&gt; ON Source: zibase.js, line 82 × Search results Close "},"ZbProtocol.html":{"id":"ZbProtocol.html","title":"Namespace: ZbProtocol","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Namespace: ZbProtocol ZbProtocol Zibase protocols Source: zibase.js, line 28 Members &lt;constant&gt; CHACON Source: zibase.js, line 36 &lt;constant&gt; DOMIA Source: zibase.js, line 38 &lt;constant&gt; PRESET Source: zibase.js, line 30 &lt;constant&gt; RFS10 Source: zibase.js, line 44 &lt;constant&gt; VISONIC433 Source: zibase.js, line 32 &lt;constant&gt; VISONIC868 Source: zibase.js, line 34 &lt;constant&gt; X2D433 Source: zibase.js, line 46 &lt;constant&gt; X2D433ALRM Source: zibase.js, line 48 &lt;constant&gt; X2D868 Source: zibase.js, line 50 &lt;constant&gt; X2D868ALRM Source: zibase.js, line 52 &lt;constant&gt; X2D868BOAC Source: zibase.js, line 58 &lt;constant&gt; X2D868INSH Source: zibase.js, line 54 &lt;constant&gt; X2D868PIWI Source: zibase.js, line 56 &lt;constant&gt; X10 Source: zibase.js, line 40 &lt;constant&gt; ZWAVE Source: zibase.js, line 42 × Search results Close "},"ZbRequest.html":{"id":"ZbRequest.html","title":"Class: ZbRequest","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Class: ZbRequest ZbRequest Handles requests to the Zibase new ZbRequest(description) Creates an empty request. Parameters: Name Type Description description string Description of the request, which is useful for error tracking and debugging. Source: zibase.js, line 111 Methods toBinaryArray() Formats the request into a binary array understandable by the Zibase. Source: zibase.js, line 132 Returns: Binary array Type Buffer × Search results Close "},"ZbResponse.html":{"id":"ZbResponse.html","title":"Class: ZbResponse","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Class: ZbResponse ZbResponse Handles responses from the Zibase new ZbResponse(buffer) Creates a response from the binary data sent by the Zibase Parameters: Name Type Description buffer Buffer Binary data Source: zibase.js, line 192 × Search results Close "},"ZbVirtualProbe.html":{"id":"ZbVirtualProbe.html","title":"Namespace: ZbVirtualProbe","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Namespace: ZbVirtualProbe ZbVirtualProbe Virtual probes Source: zibase.js, line 66 Members &lt;constant&gt; OREGON Source: zibase.js, line 68 &lt;constant&gt; OWL Source: zibase.js, line 70 × Search results Close "},"ZiBase.html":{"id":"ZiBase.html","title":"Class: ZiBase","body":" DocStrap Namespaces ZbActionZbProtocolZbVirtualProbe Classes ZbRequestZbResponseZiBase Class: ZiBase ZiBase Allows to manipulate the zibase. The IP of the zibase is needed. new ZiBase(ipAddr, deviceId, token, callback) Parameters: Name Type Description ipAddr string IP address of the zibase deviceId string Device ID of the zibase token string Token of the zibase callback function Callback to call when the connection to the zibase is established. Source: zibase.js, line 223 Extends events.EventEmitter Methods deregisterListener() Asks the Zibase to unregister the caller client Source: zibase.js, line 852 getDescriptor(id) retrieves the descriptor with a given id Parameters: Name Type Description id string ID of the descriptor to retrieve Source: zibase.js, line 318 getSensorInfo(idSensor, callback) retrieves the information about a given sensor Parameters: Name Type Description idSensor string ID of the sensor callback function Callback to be called when the info is retrieved Source: zibase.js, line 914 getState(adress, callback) Gets the state of an activator from the Zibase Parameters: Name Type Description adress string X10 formatted address of the activator callback function Callback to be called when the state is received Source: zibase.js, line 873 getVariable(numVar, callback) Get the value of a Vx variable of the Zibase Parameters: Name Type Description numVar int number of the variable (0 to 31) callback function Callback to be called when the value is retrieved Source: zibase.js, line 813 loadDescriptors(cb) Loads the descriptors of declared devices and scenarios Parameters: Name Type Description cb function Callback to be called when the descriptors are loaded Source: zibase.js, line 262 on(event, id, callback) listens to events Parameters: Name Type Argument Description event string Event to be listened to id string &lt;optional&gt; The ID of the device that triggers the event. Don't specify any when the event is triggered by the zibase callback function Callback to be called when the event is triggered. The parameters of the callback depend on the event Source: zibase.js, line 329 once(event, id, callback) same as method on but only for one event Parameters: Name Type Argument Description event string Event to be listened to id string &lt;optional&gt; The ID of the device that triggers the event. Don't specify any when the event is triggered by the zibase callback function Callback to be called when the event is triggered. The parameters of the callback depend on the event Source: zibase.js, line 346 See: Zibase#on processZiBaseData(response) process the information messages sent by the zibase.Emits events depending on the content of the response. Parameters: Name Type Description response Response A response to process, as sent by the zibase Source: zibase.js, line 363 registerListener(port) Asks the Zibase to register the caller client as a listener.After this call, the Zibase will send its activity log to the caller, on the given port. Parameters: Name Type Description port int The port to listen in order to receive the messages Source: zibase.js, line 834 runScenario(scenario) Asks the zibase to run the scenario specified by its number Parameters: Name Type Description scenario int | string the scenario number or name Source: zibase.js, line 732 Returns: false if scenario doesn't resolve to a scenario number Type boolean sendCommand(address, action, protocol, dimLevel, nbBurst) Ask the zibase to send a command to an activator specified by its ID and protocol Parameters: Name Type Description address string Address of the activator in X10 format (e.g. B5) action ZbAction Action to execute protocol ZbProtocol Protocol RF to be used dimLevel int Not supported by the Zibase for now nbBurst int Number of RF emissions Source: zibase.js, line 683 sendRequest(request, withResponse, callback) Sends a request to the zibase Parameters: Name Type Description request ZbRequest Request to be sent withResponse boolean Indicates if a response is to be expected callback function Callback to be called when the response is received Source: zibase.js, line 594 setEvent(action, address) Positions a Zibase alert to the state ON or OFF, or simulates a sensor ID message in the activity log of the Zibase Parameters: Name Type Description action int The action: 0 - deactivate an alert, 1 - activate an alert, 2 - simulate a sensor ID message (can trigger the execution of a scenario) address string Address of the activator in X10 format (e.g. B5 or ZA14) Source: zibase.js, line 767 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
